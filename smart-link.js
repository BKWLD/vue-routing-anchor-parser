'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

// Generated by CoffeeScript 2.2.4
// Render a nuxt-link if an internal link or a v-parse-anchor wrapped a if not.
// This is so that link pre-fetching works.
var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

exports.default = {
  name: 'SmartLink',
  functional: true,
  props: {
    to: String, // The URL gets passed here
    internalTrailingSlash: Boolean // Optionally add trailing slash if is internal link
  },

  // Destructure the props and data we care about
  // props: { to, internalTrailingSlash }
  render: function render(create, _ref) {
    var props = _ref.props,
        data = _ref.data,
        listeners = _ref.listeners,
        children = _ref.children;

    var internalTrailingSlash, to;
    to = props.to;
    internalTrailingSlash = props.internalTrailingSlash;
    console.log('rendering link, to is', to, 'internaltrailingslash is', internalTrailingSlash, 'props are', props);
    if (!to) {
      return create('span', data, children);
    }
    // Test if an internal link
    if ((0, _index.isInternal)(to)) {
      // Render a nuxt-link
      return create('nuxt-link', _extends({}, data, {
        nativeOn: listeners, // nuxt-link doesn't forward events on it's own
        props: {
          to: internalTrailingSlash ? (0, _index.makeRouterPath)((0, _index.addTrailingSlash)(to)) : (0, _index.makeRouterPath)(to)
        }
      }), children);
    } else {
      // Make a standard link that opens in a new window
      return create('a', _extends({}, data, {
        attrs: _extends({}, data.attrs, {
          href: to,
          target: (0, _index.shouldOpenInNewWindow)(to) ? '_blank' : void 0
        })
      }), children);
    }
  }
};