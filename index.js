'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addTrailingSlash = exports.shouldOpenInNewWindow = exports.makeRouterPath = exports.isInternal = exports.handleAnchor = undefined;

var _urlParse = require('url-parse');

var _urlParse2 = _interopRequireDefault(_urlParse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 2.2.4
// Deps
var bind,
    handleExternal,
    handleInternal,
    makeUrlObj,
    mergeSettings,
    settings,
    _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
},
    indexOf = [].indexOf;

// Default settings
settings = {
  addBlankToExternal: false,
  addTrailingSlashToInternal: false,
  internalUrls: [],
  sameWindowUrls: [],
  internalHosts: [],
  externalPaths: []
};

// Override the settings
mergeSettings = function mergeSettings(choices) {
  return settings = _extends({}, settings, choices);
};

// Add listeners to anchors
bind = function bind(el, binding, vnode) {
  var anchor, i, len, ref, results, router;
  // Get the router instance
  router = vnode.context.$router;
  if (el.tagName.toLowerCase() === 'a') {
    // Handle self
    handleAnchor(el, router);
  }
  ref = el.querySelectorAll('a');
  results = [];
  for (i = 0, len = ref.length; i < len; i++) {
    anchor = ref[i];
    // Handle child anchors that have an href
    results.push(handleAnchor(anchor, router));
  }
  return results;
};

// Check an anchor tag
var handleAnchor = exports.handleAnchor = function handleAnchor(anchor, router) {
  var url;
  // If an explicit target attribute is set, then abort.  Assuming the author
  // of the content knew what they were doing.
  if (anchor.getAttribute('target')) {
    return;
  }
  if (url = anchor.getAttribute('href')) {
    if (isInternal(url)) {
      return handleInternal(anchor, url, router);
    } else {
      return handleExternal(anchor, url);
    }
  }
};

// Test if an anchor is an internal link
var isInternal = exports.isInternal = function isInternal(url) {
  var i, j, len, len1, pathRegex, ref, ref1, ref2, urlObj, urlRegex;
  urlObj = makeUrlObj(url);
  ref = settings.externalPaths;
  // Does it match externalPaths
  for (i = 0, len = ref.length; i < len; i++) {
    pathRegex = ref[i];
    if (urlObj.pathname.match(pathRegex)) {
      return false;
    }
  }
  if (urlObj.href.match(/^\/(?!\/)/)) {
    // Does it begin with a / and not an // ?
    return true;
  }
  if (urlObj.href.match(/^#/)) {
    // Does it begin with a hash, meaning a link to down page?
    return true;
  }
  ref1 = settings.internalUrls;
  // Does the host match internal URLs?
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    urlRegex = ref1[j];
    if (urlObj.href.match(urlRegex)) {
      return true;
    }
  }
  if (ref2 = urlObj.host, indexOf.call(settings.internalHosts, ref2) >= 0) {
    // Does the host match internal hosts?
    return true;
  }
};

// Make a URL instance from url strings
makeUrlObj = function makeUrlObj(url) {
  if (typeof url !== 'string') {
    // Already a URL object
    return url;
  }
  // Return URL object. Passing an empty object to 2nd param so functions
  // the same during SSR as client side
  return new _urlParse2.default(url, {});
};

// Add click bindings to internal links that resolve.  Thus, if the Vue doesn't
// know about a route, it will not be handled by vue-router.  Though it won't
// open in a new window.
handleInternal = function handleInternal(anchor, url, router) {
  var path;
  path = makeRouterPath(url);
  if (router.resolve({ path: path }).route.matched.length) {
    return anchor.addEventListener('click', function (e) {
      e.preventDefault();
      return router.push({ path: path });
    });
  }
};

// Make routeable path
var makeRouterPath = exports.makeRouterPath = function makeRouterPath(url) {
  var urlObj;
  urlObj = makeUrlObj(url);
  return '' + urlObj.pathname + urlObj.query + urlObj.hash;
};

// Add target blank to external links
handleExternal = function handleExternal(anchor, url) {
  if (shouldOpenInNewWindow(url) && !anchor.hasAttribute('target')) {
    return anchor.setAttribute('target', '_blank');
  }
};

// Should external link open in a new window
var shouldOpenInNewWindow = exports.shouldOpenInNewWindow = function shouldOpenInNewWindow(url) {
  var i, len, ref, urlObj, urlRegex;
  if (!settings.addBlankToExternal) {
    return false;
  }
  urlObj = makeUrlObj(url);
  if (urlObj.href.match(/^javascript:/)) {
    // A javascript:func() link
    return false;
  }
  ref = settings.sameWindowUrls;
  for (i = 0, len = ref.length; i < len; i++) {
    urlRegex = ref[i];
    if (urlObj.href.match(urlRegex)) {
      return false;
    }
  }
  return true;
};

// Add trailing slash if one is missing, returning a string
var addTrailingSlash = exports.addTrailingSlash = function addTrailingSlash(url) {
  var urlObj;
  urlObj = makeUrlObj(url);
  if (urlObj.pathname.match(/\/$/)) {
    urlObj.pathname += '/';
  }
  return urlObj.toString();
};

exports.default = {
  // Directive definition with settings method for overriding the default settings.
  // I'm relying on Browser garbage collection to cleanup listeners.
  bind: bind,
  settings: mergeSettings
};